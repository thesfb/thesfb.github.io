<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Zero-Knowledge Proofs: How I Think About Them | Home</title><meta name=keywords content><meta name=description content="When I look at most verification systems, I see the same pattern repeated everywhere: verification is implemented by disclosure. Secrets are transmitted, identifiers are stored, and trust is externalized to databases and operators. From an engineering perspective, this is a fragile design choice.
Zero-knowledge proofs give me a different primitive: verification without disclosure. Not as a policy decision, but as a cryptographic guarantee. While this particular blog is meant to be an introduction to ZKPS, I&rsquo;ll post followups where I will go in deatil into implementation, the tech behind it and real world use-cases."><meta name=author content><link rel=canonical href=https://thesfb.github.io/posts/zk-proofs/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://thesfb.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thesfb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://thesfb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://thesfb.github.io/apple-touch-icon.png><link rel=mask-icon href=https://thesfb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://thesfb.github.io/posts/zk-proofs/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://thesfb.github.io/posts/zk-proofs/"><meta property="og:site_name" content="Home"><meta property="og:title" content="Zero-Knowledge Proofs: How I Think About Them"><meta property="og:description" content="When I look at most verification systems, I see the same pattern repeated everywhere: verification is implemented by disclosure. Secrets are transmitted, identifiers are stored, and trust is externalized to databases and operators. From an engineering perspective, this is a fragile design choice.
Zero-knowledge proofs give me a different primitive: verification without disclosure. Not as a policy decision, but as a cryptographic guarantee. While this particular blog is meant to be an introduction to ZKPS, I’ll post followups where I will go in deatil into implementation, the tech behind it and real world use-cases."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-31T19:22:54+05:30"><meta property="article:modified_time" content="2025-12-31T19:22:54+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zero-Knowledge Proofs: How I Think About Them"><meta name=twitter:description content="When I look at most verification systems, I see the same pattern repeated everywhere: verification is implemented by disclosure. Secrets are transmitted, identifiers are stored, and trust is externalized to databases and operators. From an engineering perspective, this is a fragile design choice.
Zero-knowledge proofs give me a different primitive: verification without disclosure. Not as a policy decision, but as a cryptographic guarantee. While this particular blog is meant to be an introduction to ZKPS, I&rsquo;ll post followups where I will go in deatil into implementation, the tech behind it and real world use-cases."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://thesfb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Zero-Knowledge Proofs: How I Think About Them","item":"https://thesfb.github.io/posts/zk-proofs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zero-Knowledge Proofs: How I Think About Them","name":"Zero-Knowledge Proofs: How I Think About Them","description":"When I look at most verification systems, I see the same pattern repeated everywhere: verification is implemented by disclosure. Secrets are transmitted, identifiers are stored, and trust is externalized to databases and operators. From an engineering perspective, this is a fragile design choice.\nZero-knowledge proofs give me a different primitive: verification without disclosure. Not as a policy decision, but as a cryptographic guarantee. While this particular blog is meant to be an introduction to ZKPS, I\u0026rsquo;ll post followups where I will go in deatil into implementation, the tech behind it and real world use-cases.\n","keywords":[],"articleBody":"When I look at most verification systems, I see the same pattern repeated everywhere: verification is implemented by disclosure. Secrets are transmitted, identifiers are stored, and trust is externalized to databases and operators. From an engineering perspective, this is a fragile design choice.\nZero-knowledge proofs give me a different primitive: verification without disclosure. Not as a policy decision, but as a cryptographic guarantee. While this particular blog is meant to be an introduction to ZKPS, I’ll post followups where I will go in deatil into implementation, the tech behind it and real world use-cases.\nThis post is how I think about zero-knowledge proofs when designing or evaluating systems—not as a concept, but as an engineering tool.\nPart 1: The Engineering Problem ZK Solves Most systems need to answer binary questions:\nIs this user authorized?\nDoes this transaction follow the rules?\nDoes this input satisfy a constraint?\nTraditionally, we answer these questions by moving data to the verifier.\nThat creates several problems:\nSecrets exist outside their original trust boundary\nDatabases become long-lived attack surfaces\nBreaches scale catastrophically\nVerification logic is coupled to data retention\nFrom an engineering standpoint, this is unnecessary coupling.\nZero-knowledge proofs let me decouple verification from data possession. The verifier checks correctness of a statement. It never receives the underlying witness.\nTraditional vs ZK-Based Verification Aspect Traditional Systems ZK-Based Systems Verification method Data disclosure Proof verification Secret handling Stored or transmitted Never leaves prover Breach impact High Limited Trust assumptions Operators + storage Cryptography only What I gain is a strictly smaller trust surface.\nPart 2: Formal Model (What I Actually Rely On) I model a zero-knowledge proof as a protocol between:\nProver (P): holds a witness w\nVerifier (V): checks a statement S\nThe prover wants to convince the verifier that:\n∃ w such that C(w) = true\nWhere C is a constraint system.\nFor this to work, the protocol must satisfy:\nProperty Engineering Interpretation Completeness Valid executions always pass Soundness Invalid executions almost never pass Zero-knowledge Verifier cannot extract w The zero-knowledge property is formalized via simulation. If a simulator can generate an indistinguishable proof transcript without access to w, then no information about w is leaked.\nThis is the core guarantee I rely on. Everything else is an optimization.\nComputation, Not Statements Modern ZK systems prove statements about computation, not just facts.\nAs an engineer, I think in terms of pipelines:\nWrite a program / computation\nCompile it into a constraint system\nTreat private inputs as the witness\nGenerate a proof of constraint satisfaction\nVerify the proof with minimal overhead\nMost systems today use variants of arithmetic circuits or R1CS (Rank-1 Constraint Systems) to represent computation.\nWhat the Verifier Checks Constraint satisfaction\nProof validity\nNothing about inputs or intermediate values\nThe verifier does not re-run the computation.\nProof Systems I Care About System Why I’d Choose It Cost zk-SNARKs Very small proofs, fast verification Trusted setup zk-STARKs Transparent, no trusted setup Larger proofs, more bandwidth Bulletproofs No setup, simpler assumptions Slower verification Trade-offs are explicit. Zero-knowledge does not remove cost—it reallocates it.\nProperties That Matter in Real Systems These are the properties I evaluate before adopting ZK in a system:\nNon-interactivity\nProofs must be verifiable without interaction.\nSuccinct verification\nVerification must be cheaper than recomputation.\nComposable security\nProofs must compose safely with other protocols.\nFailure containment\nProof generation failure should not leak secrets.\nIf any of these fail, ZK becomes academic instead of practical.\nWhere ZK Fits Well (and Where It Doesn’t) Good Fits Blockchain validation (L2 rollups, private transactions)\nAuthentication without password transmission\nVerifiable computation on untrusted infrastructure\nSelective disclosure credentials\nPoor Fits Low-latency systems with tight compute budgets\nSystems where data disclosure is already acceptable\nTeams without cryptographic review capacity\nZK systems are powerful, but unforgiving. Incorrect circuit design is a correctness bug, not a performance issue.\nThe Cost I Accept as an Engineer Cost Why I Accept It Expensive proving Reduces trust assumptions Complex tooling Eliminates data retention risk Hard debugging Prevents catastrophic leaks What I’m trading is developer convenience for system robustness.\nWhy I Think ZK Is an Engineering Primitive, Not a Feature Most security failures I’ve dealt with trace back to excess data existing somewhere it shouldn’t. Zero-knowledge proofs attack that problem directly by making certain classes of data unnecessary.\nThey don’t rely on:\nHonest operators\nSecure databases\nCorrect policy enforcement\nThey rely on math and constraints.\nFrom an engineering perspective, that’s a win. I’d rather reason about constraint satisfaction than trust that no one will misuse stored secrets.\nI don’t use zero-knowledge proofs everywhere. But when verification and privacy collide, they’re the cleanest abstraction I know.\nIf a system doesn’t need to know something, I don’t think it should be able to learn it.\nThat’s the engineering argument for zero-knowledge.\n","wordCount":"791","inLanguage":"en","datePublished":"2025-12-31T19:22:54+05:30","dateModified":"2025-12-31T19:22:54+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://thesfb.github.io/posts/zk-proofs/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"https://thesfb.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://thesfb.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://thesfb.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://thesfb.github.io/about/ title=Resume><span>Resume</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Zero-Knowledge Proofs: How I Think About Them</h1><div class=post-meta><span title='2025-12-31 19:22:54 +0530 +0530'>December 31, 2025</span>&nbsp;·&nbsp;<span>4 min</span></div></header><div class=post-content><p>When I look at most verification systems, I see the same pattern repeated everywhere: verification is implemented by disclosure. Secrets are transmitted, identifiers are stored, and trust is externalized to databases and operators. From an engineering perspective, this is a fragile design choice.</p><p>Zero-knowledge proofs give me a different primitive: <strong>verification without disclosure</strong>. Not as a policy decision, but as a cryptographic guarantee. While this particular blog is meant to be an introduction to ZKPS, I&rsquo;ll post followups where I will go in deatil into implementation, the tech behind it and real world use-cases.</p><p>This post is how I think about zero-knowledge proofs when designing or evaluating systems&mdash;not as a concept, but as an engineering tool.</p><h2 id=part-1-the-engineering-problem-zk-solves><strong>Part 1: The Engineering Problem ZK Solves</strong><a hidden class=anchor aria-hidden=true href=#part-1-the-engineering-problem-zk-solves>#</a></h2><p>Most systems need to answer binary questions:</p><ul><li><p>Is this user authorized?</p></li><li><p>Does this transaction follow the rules?</p></li><li><p>Does this input satisfy a constraint?</p></li></ul><p>Traditionally, we answer these questions by moving data to the verifier.</p><p>That creates several problems:</p><ul><li><p>Secrets exist outside their original trust boundary</p></li><li><p>Databases become long-lived attack surfaces</p></li><li><p>Breaches scale catastrophically</p></li><li><p>Verification logic is coupled to data retention</p></li></ul><p>From an engineering standpoint, this is unnecessary coupling.</p><p>Zero-knowledge proofs let me decouple <strong>verification</strong> from <strong>data possession</strong>. The verifier checks correctness of a statement. It never receives the underlying witness.</p><h3 id=traditional-vs-zk-based-verification><strong>Traditional vs ZK-Based Verification</strong><a hidden class=anchor aria-hidden=true href=#traditional-vs-zk-based-verification>#</a></h3><table><thead><tr><th><strong>Aspect</strong></th><th><strong>Traditional Systems</strong></th><th><strong>ZK-Based Systems</strong></th></tr></thead><tbody><tr><td>Verification method</td><td>Data disclosure</td><td>Proof verification</td></tr><tr><td>Secret handling</td><td>Stored or transmitted</td><td>Never leaves prover</td></tr><tr><td>Breach impact</td><td>High</td><td>Limited</td></tr><tr><td>Trust assumptions</td><td>Operators + storage</td><td>Cryptography only</td></tr></tbody></table><p>What I gain is a strictly smaller trust surface.</p><h2 id=part-2-formal-model-what-i-actually-rely-on><strong>Part 2: Formal Model (What I Actually Rely On)</strong><a hidden class=anchor aria-hidden=true href=#part-2-formal-model-what-i-actually-rely-on>#</a></h2><p>I model a zero-knowledge proof as a protocol between:</p><ul><li><p><strong>Prover (P)</strong>: holds a witness <em>w</em></p></li><li><p><strong>Verifier (V)</strong>: checks a statement <em>S</em></p></li></ul><p>The prover wants to convince the verifier that:</p><blockquote><p>∃ w such that C(w) = true</p></blockquote><p>Where <em>C</em> is a constraint system.</p><p>For this to work, the protocol must satisfy:</p><table><thead><tr><th><strong>Property</strong></th><th><strong>Engineering Interpretation</strong></th></tr></thead><tbody><tr><td>Completeness</td><td>Valid executions always pass</td></tr><tr><td>Soundness</td><td>Invalid executions almost never pass</td></tr><tr><td>Zero-knowledge</td><td>Verifier cannot extract <em>w</em></td></tr></tbody></table><p>The zero-knowledge property is formalized via <strong>simulation</strong>. If a simulator can generate an indistinguishable proof transcript without access to <em>w</em>, then no information about <em>w</em> is leaked.</p><p>This is the core guarantee I rely on. Everything else is an optimization.</p><h2 id=computation-not-statements><strong>Computation, Not Statements</strong><a hidden class=anchor aria-hidden=true href=#computation-not-statements>#</a></h2><p>Modern ZK systems prove statements about <strong>computation</strong>, not just facts.</p><p>As an engineer, I think in terms of pipelines:</p><ol><li><p>Write a program / computation</p></li><li><p>Compile it into a constraint system</p></li><li><p>Treat private inputs as the witness</p></li><li><p>Generate a proof of constraint satisfaction</p></li><li><p>Verify the proof with minimal overhead</p></li></ol><p>Most systems today use variants of <strong>arithmetic circuits</strong> or <strong>R1CS (Rank-1 Constraint Systems)</strong> to represent computation.</p><h3 id=what-the-verifier-checks><strong>What the Verifier Checks</strong><a hidden class=anchor aria-hidden=true href=#what-the-verifier-checks>#</a></h3><ul><li><p>Constraint satisfaction</p></li><li><p>Proof validity</p></li><li><p>Nothing about inputs or intermediate values</p></li></ul><p>The verifier does <em>not</em> re-run the computation.</p><h2 id=proof-systems-i-care-about><strong>Proof Systems I Care About</strong><a hidden class=anchor aria-hidden=true href=#proof-systems-i-care-about>#</a></h2><table><thead><tr><th><strong>System</strong></th><th><strong>Why I&rsquo;d Choose It</strong></th><th><strong>Cost</strong></th></tr></thead><tbody><tr><td>zk-SNARKs</td><td>Very small proofs, fast verification</td><td>Trusted setup</td></tr><tr><td>zk-STARKs</td><td>Transparent, no trusted setup</td><td>Larger proofs, more bandwidth</td></tr><tr><td>Bulletproofs</td><td>No setup, simpler assumptions</td><td>Slower verification</td></tr></tbody></table><p>Trade-offs are explicit. Zero-knowledge does not remove cost&mdash;it reallocates it.</p><h2 id=properties-that-matter-in-real-systems><strong>Properties That Matter in Real Systems</strong><a hidden class=anchor aria-hidden=true href=#properties-that-matter-in-real-systems>#</a></h2><p>These are the properties I evaluate before adopting ZK in a system:</p><ul><li><p><strong>Non-interactivity</strong></p><blockquote><p>Proofs must be verifiable without interaction.</p></blockquote></li><li><p><strong>Succinct verification</strong></p><blockquote><p>Verification must be cheaper than recomputation.</p></blockquote></li><li><p><strong>Composable security</strong></p><blockquote><p>Proofs must compose safely with other protocols.</p></blockquote></li><li><p><strong>Failure containment</strong></p><blockquote><p>Proof generation failure should not leak secrets.</p></blockquote></li></ul><p>If any of these fail, ZK becomes academic instead of practical.</p><h2 id=where-zk-fits-well-and-where-it-doesn><strong>Where ZK Fits Well (and Where It Doesn&rsquo;t)</strong><a hidden class=anchor aria-hidden=true href=#where-zk-fits-well-and-where-it-doesn>#</a></h2><h3 id=good-fits><strong>Good Fits</strong><a hidden class=anchor aria-hidden=true href=#good-fits>#</a></h3><ul><li><p>Blockchain validation (L2 rollups, private transactions)</p></li><li><p>Authentication without password transmission</p></li><li><p>Verifiable computation on untrusted infrastructure</p></li><li><p>Selective disclosure credentials</p></li></ul><h3 id=poor-fits><strong>Poor Fits</strong><a hidden class=anchor aria-hidden=true href=#poor-fits>#</a></h3><ul><li><p>Low-latency systems with tight compute budgets</p></li><li><p>Systems where data disclosure is already acceptable</p></li><li><p>Teams without cryptographic review capacity</p></li></ul><p>ZK systems are powerful, but unforgiving. Incorrect circuit design is a correctness bug, not a performance issue.</p><h2 id=the-cost-i-accept-as-an-engineer><strong>The Cost I Accept as an Engineer</strong><a hidden class=anchor aria-hidden=true href=#the-cost-i-accept-as-an-engineer>#</a></h2><table><thead><tr><th><strong>Cost</strong></th><th><strong>Why I Accept It</strong></th></tr></thead><tbody><tr><td>Expensive proving</td><td>Reduces trust assumptions</td></tr><tr><td>Complex tooling</td><td>Eliminates data retention risk</td></tr><tr><td>Hard debugging</td><td>Prevents catastrophic leaks</td></tr></tbody></table><p>What I&rsquo;m trading is <strong>developer convenience</strong> for <strong>system robustness</strong>.</p><h2 id=why-i-think-zk-is-an-engineering-primitive-not-a-feature><strong>Why I Think ZK Is an Engineering Primitive, Not a Feature</strong><a hidden class=anchor aria-hidden=true href=#why-i-think-zk-is-an-engineering-primitive-not-a-feature>#</a></h2><p>Most security failures I&rsquo;ve dealt with trace back to excess data existing somewhere it shouldn&rsquo;t. Zero-knowledge proofs attack that problem directly by making certain classes of data <em>unnecessary</em>.</p><p>They don&rsquo;t rely on:</p><ul><li><p>Honest operators</p></li><li><p>Secure databases</p></li><li><p>Correct policy enforcement</p></li></ul><p>They rely on math and constraints.</p><p>From an engineering perspective, that&rsquo;s a win. I&rsquo;d rather reason about constraint satisfaction than trust that no one will misuse stored secrets.</p><p>I don&rsquo;t use zero-knowledge proofs everywhere. But when verification and privacy collide, they&rsquo;re the cleanest abstraction I know.</p><p>If a system doesn&rsquo;t need to know something, I don&rsquo;t think it should be able to learn it.</p><p>That&rsquo;s the engineering argument for zero-knowledge.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://thesfb.github.io/>Home</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>